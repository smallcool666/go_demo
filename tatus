[1mdiff --git a/src/ch3/example/surface.go b/src/ch3/example/surface.go[m
[1mindex 3e4cfe4..e6451b9 100644[m
[1m--- a/src/ch3/example/surface.go[m
[1m+++ b/src/ch3/example/surface.go[m
[36m@@ -1,5 +1,48 @@[m
 package main[m
 [m
[32m+[m[32mimport ([m
[32m+[m	[32m"fmt"[m
[32m+[m	[32m"math"[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mconst ([m
[32m+[m	[32mwidth, height = 600, 320            // canvas size in pixels[m
[32m+[m	[32mcells         = 100                 // number of grid cells[m
[32m+[m	[32mxyrange       = 30.0                // axis ranges (-xyrange..+xyrange)[m
[32m+[m	[32mxyscale       = width / 2 / xyrange // pixels per x or y unit[m
[32m+[m	[32mzscale        = height * 0.4        // pixels per z unit[m
[32m+[m	[32mangle         = math.Pi / 6         // angle of x, y axes (=30°)[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mvar sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°)[m
 func main() {[m
[31m-	$END$[m
[32m+[m	[32mfmt.Printf("<svg xmlns='http://www.w3.org/2000/svg' "+[m
[32m+[m		[32m"style='stroke: grey; fill: white; stroke-width: 0.7' "+[m
[32m+[m		[32m"width='%d' height='%d'>", width, height)[m
[32m+[m	[32mfor i := 0; i < cells; i++ {[m
[32m+[m		[32mfor j := 0; j < cells; j++ {[m
[32m+[m			[32max, ay := corner(i+1, j)[m
[32m+[m			[32mbx, by := corner(i, j)[m
[32m+[m			[32mcx, cy := corner(i, j+1)[m
[32m+[m			[32mdx, dy := corner(i+1, j+1)[m
[32m+[m			[32mfmt.Printf("<polygon points='%g,%g %g,%g %g,%g %g,%g'/>\n",[m
[32m+[m				[32max, ay, bx, by, cx, cy, dx, dy)[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m	[32mfmt.Println("</svg>")[m
[32m+[m[32m}[m
[32m+[m[32mfunc corner(i, j int) (float64, float64) {[m
[32m+[m	[32m// Find point (x,y) at corner of cell (i,j).[m
[32m+[m	[32mx := xyrange * (float64(i)/cells - 0.5)[m
[32m+[m	[32my := xyrange * (float64(j)/cells - 0.5)[m
[32m+[m	[32m// Compute surface height z.[m
[32m+[m	[32mz := f(x, y)[m
[32m+[m	[32m// Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy).[m
[32m+[m	[32msx := width/2 + (x-y)*cos30*xyscale[m
[32m+[m	[32msy := height/2 + (x+y)*sin30*xyscale - z*zscale[m
[32m+[m	[32mreturn sx, sy[m
[32m+[m[32m}[m
[32m+[m[32mfunc f(x, y float64) float64 {[m
[32m+[m	[32mr := math.Hypot(x, y) // distance from (0,0)[m
[32m+[m	[32mreturn math.Sin(r) / r[m
 }[m
[1mdiff --git a/src/ch3/float.go b/src/ch3/float.go[m
[1mindex 3e4cfe4..67c8e36 100644[m
[1m--- a/src/ch3/float.go[m
[1m+++ b/src/ch3/float.go[m
[36m@@ -1,5 +1,51 @@[m
 package main[m
 [m
[32m+[m[32mimport ([m
[32m+[m	[32m"fmt"[m
[32m+[m	[32m"math"[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m	[32m浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。[m
[32m+[m	[32m一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确[m
[32m+[m[32m表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）[m
[32m+[m	[32m用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度[m
[32m+[m[32m和控制打印精度。[m
[32m+[m	[32mmath包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：[m
[32m+[m		[32m正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1).[m
[32m+[m
[32m+[m	[32m***函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等[m
[32m+[m[32m的（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）[m
[32m+[m
[32m+[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m//很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分[m
[32m+[m[32mconst Avogadro = 6.02214129e23 // 阿伏伽德罗常数[m
[32m+[m[32mconst Planck = 6.62606957e-34 // 普朗克常数[m
[32m+[m
[32m+[m
 func main() {[m
[31m-	$END$[m
[32m+[m	[32mfmt.Println(math.MaxFloat32,  math.MaxFloat64) //3.4028234663852886e+38 1.7976931348623157e+308[m
[32m+[m
[32m+[m	[32m//float32精度有限导致误差[m
[32m+[m	[32mvar f float32 = 1 << 24 // 值为16777216[m
[32m+[m	[32mfmt.Println(f == f+1) // "true"[m
[32m+[m
[32m+[m	[32mfor x := 4; x < 8; x++ {[m
[32m+[m		[32mfmt.Printf("x = %d e^x = %8.3f\n", x, math.Exp(float64(x)))[m
[32m+[m	[32m}[m
[32m+[m[32m/*	x = 4 e^x =   54.598[m
[32m+[m	[32mx = 5 e^x =  148.413[m
[32m+[m	[32mx = 6 e^x =  403.429[m
[32m+[m	[32mx = 7 e^x = 1096.633[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m	[32m//无穷和非数字[m
[32m+[m	[32mvar z float64[m
[32m+[m	[32mfmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"[m
[32m+[m
[32m+[m	[32m//NaN和任意数都不相等[m
[32m+[m	[32mnan := math.NaN()[m
[32m+[m	[32mfmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"[m
 }[m
[1mdiff --git a/src/ch3/int.go b/src/ch3/int.go[m
[1mindex 3e4cfe4..812a05c 100644[m
[1m--- a/src/ch3/int.go[m
[1m+++ b/src/ch3/int.go[m
[36m@@ -1,5 +1,82 @@[m
 package main[m
 [m
[32m+[m[32mimport "fmt"[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m	[32mGo语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整形数类型，分别对应8、16、32、64bit大小的有符号整形数，与此对应的是uint8、[m
[32m+[m[32muint16、uint32和uint64四种无符号整形数类型。[m
[32m+[m	[32m还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设；因为不同的编[m
[32m+[m[32m译器即使在相同的硬件平台上可能产生不同的大小。[m
[32m+[m	[32mUnicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。[m
[32m+[m	[32m同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。[m
[32m+[m	[32m最后，还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程是才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。[m
[32m+[m
[32m+[m	[32m不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。[m
[32m+[m	[32m有符号整数采用2的补码形式表示，也就是最高bit位用作表示符号位，一个n-bit的有符号数的值域是从-2^{n-1}到 2^{n-1}−1。[m
[32m+[m	[32mGo语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照先级递减的顺序的排列：[m
[32m+[m		[32m* / % << >> & &^[m
[32m+[m		[32m+ - | ^[m
[32m+[m		[32m== != < <= > >=[m
[32m+[m		[32m&&[m
[32m+[m		[32m||[m
[32m+[m	[32m算术运算符+、-、*和/可以适用与于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。[m
[32m+[m	[32m对于不同编程语言，%取模运算的行为可能并不相同。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。[m
[32m+[m	[32m除法运算符/的行为则依赖于操作数是否为全为整数，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。[m
[32m+[m
[32m+[m	[32m如果原始的数值是有符号类型，而且最左边的bit为是1的话，那么最终结果可能是负的[m
[32m+[m
[32m+[m	[32m***整数、浮点数和字符串可以根据比较结果排序。许多其它类型的值可能是不可比较的，因此也就可能是不可排序的。[m
[32m+[m
[32m+[m	[32mbit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数:[m
[32m+[m		[32m& 位运算 AND[m
[32m+[m		[32m| 位运算 OR[m
[32m+[m		[32m^ 位运算 XOR[m
[32m+[m		[32m&^ 位清空 (AND NOT)[m
[32m+[m		[32m<< 左移[m
[32m+[m		[32m>> 右移[m
[32m+[m	[32m位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反[m
[32m+[m	[32m位操作运算符&^用于按位置零（AND NOT）[m
[32m+[m	[32m左移运算用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位，但是有符号数的右移运算会用符号位的值填充左边空缺的bit位。因为这个原因，最好用无符号运算，这样你可以将整[m
[32m+[m[32m数完全当作一个bit位模式处理。[m
[32m+[m
[32m+[m	[32m***无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。[m
[32m+[m
[32m+[m	[32m许多整形数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值。但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度[m
[32m+[m	[32m浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。应该避免对可能会超出目标类型表示范围的数值类型转换，因为截断的行为可能依赖于具体的实现[m
[32m+[m[32m*/[m
 func main() {[m
[31m-	$END$[m
[32m+[m	[32m//%取模运算符的符号和被取模数的符号总是一致的[m
[32m+[m	[32mfmt.Println(5%3, -5%3, 5%-3, -5%-3) //2 -2 2 -2[m
[32m+[m	[32m//整数除法会向着0方向截断余数[m
[32m+[m	[32mfmt.Println(5/4, 5.0/4, 5.0/4.0, 5/4.0)//1 1.25 1.25 1.25[m
[32m+[m
[32m+[m	[32m//如果原始的数值是有符号类型，而且最左边的bit为是1的话，那么最终结果可能是负的[m
[32m+[m	[32mvar u uint8 = 255[m
[32m+[m	[32mfmt.Println(u, u+1, u*u) // "255 0 1"[m
[32m+[m	[32mvar i int8 = 127[m
[32m+[m	[32mfmt.Println(i, i+1, i*i) // "127 -128 1"[m
[32m+[m
[32m+[m	[32m//位运算演示[m
[32m+[m	[32mvar x uint8 = 1<<1 | 1<<5[m
[32m+[m	[32mvar y uint8 = 1<<1 | 1<<2[m
[32m+[m	[32mfmt.Printf("%08b\n", x)    // "00100010"[m
[32m+[m	[32mfmt.Printf("%08b\n", y)    // "00000110"[m
[32m+[m	[32mfmt.Printf("%08b\n", x|y)  // "00100110"[m
[32m+[m	[32mfmt.Printf("%08b\n", x^y)  // "00100100"[m
[32m+[m	[32mfmt.Printf("%08b\n", x&^y) // "00100000" 按位置零；按照y的bit位把x对应的bit位置零；y哪个bit位是1，就把x对应的bit位置为0[m
[32m+[m	[32mfmt.Printf("%08b\n", x<<1) // "01000100"[m
[32m+[m	[32mfmt.Printf("%08b\n", x>>1) // "00010001"[m
[32m+[m
[32m+[m	[32m//类型转换丢失精度[m
[32m+[m	[32mf := 3.141 // a float64[m
[32m+[m	[32min := int(f)[m
[32m+[m	[32mfmt.Println(f, in) // "3.141 3"[m
[32m+[m
[32m+[m	[32m//使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式[m
[32m+[m	[32mo := 0666[m
[32m+[m	[32mfmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"[m
[32m+[m	[32mxx := int64(0xdeadbeef)[m
[32m+[m	[32m//fmt的两个使用技巧。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。[m
[32m+[m	[32m// 第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。[m
[32m+[m	[32mfmt.Printf("%d %[1]x %#[1]x %#[1]X\n", xx)// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF[m
 }[m
[1mdiff --git "a/src/ch3/\345\244\215\346\225\260.go" "b/src/ch3/\345\244\215\346\225\260.go"[m
[1mindex 3e4cfe4..2146626 100644[m
[1m--- "a/src/ch3/\345\244\215\346\225\260.go"[m
[1m+++ "b/src/ch3/\345\244\215\346\225\260.go"[m
[36m@@ -1,5 +1,15 @@[m
 package main[m
 [m
[32m+[m[32mimport "fmt"[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m	[32mGo语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部[m
[32m+[m	[32m在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i或与之等价的写法2i+1。[m
[32m+[m[32m*/[m
 func main() {[m
[31m-	$END$[m
[32m+[m	[32mvar x complex128 = complex(1, 2) // 1+2i[m
[32m+[m	[32mvar y complex128 = complex(3, 4) // 3+4i[m
[32m+[m	[32mfmt.Println(x*y) // "(-5+10i)"[m
[32m+[m	[32mfmt.Println(real(x*y)) // "-5"[m
[32m+[m	[32mfmt.Println(imag(x*y)) // "10"[m
 }[m
