package main
/*
	当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用
到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法。
	在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。
	只有类型(Point)和指向他们的指针(*Point)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出
现在接收器中的。
	想要调用指针类型方法(*Point).ScaleBy，只要提供一个Point类型的指针即可。
	编译器会隐式地帮我们用&p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法
取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到。
	下面三种情况里的任意一种情况都是合法的方法调用表达式：
		不论是接收器的实际参数和其接收器的形式参数相同，比如两者都是类型T或者都是类型*T；
		或者接收器形参是类型T，但接收器实参是类型*T，这种情况下编译器会隐式地为我们取变量的地址；
		或者接收器形参是类型*T，实参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量。

	就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice。
	就像在普通函数中一样，虽然可以通过引用来操作内部值，但在方法想要修改引用本身是不会影响原始值的，比如把他置为nil，或者让这个引用指向了其它的对象，调用方都不会受影
响。（译注：因为传入的是存储了内存地址的变量，你改变这个变量是影响不了原始的变量的，想想C语言，是差不多的）
*/
//方法的名字是(*Point).ScaleBy。这里的括号是必须的；没有括号的话这个表达式可能会被理解为*(Point.ScaleBy)
func (p *Point) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}
func main() {
	//调用指针类型方法(*Point).ScaleBy，只要提供一个Point类型的指针
	//调用1
	r := &Point{1, 2}
	r.ScaleBy(2)
	p := Point{1, 2}
	//调用2
	pptr := &p
	pptr.ScaleBy(2)
	//调用3
	(&p).ScaleBy(2)
	//调用4，编译器会隐式地帮我们用&p去调用ScaleBy这个方法
	p.ScaleBy(2)
	//不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量
	Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
	//调用5，此处pttr是指针，*pttr 相当于一个变量，实质和调用4一致
	(*pptr).ScaleBy(2)
}
