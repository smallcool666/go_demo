package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
)

/*
	类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。
	这里有两种可能。第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类
型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。
	第二种，如果相反断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型T。
换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分。
	如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像赋值操作一样，除
了对于nil接口值的情况。
	如果类型断言出现在一个预期有两个结果的赋值操作中，这个操作不会在失败的时候发生panic但是代替地返回一个额外的第二个结果，这个结果是一个标识成功的布尔值。
*/
func main() {
	var w io.Writer
	w = os.Stdout
	f := w.(*os.File) // success: f == os.Stdout
	//c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer
	var w1  io.Writer = os.Stdout
	f1, ok := w1.(*os.File) // success: ok, f == os.Stdout
	b, ok := w1.(*bytes.Buffer) // failure: !ok, b == nil
	fmt.Println(f, ok, b)
	fmt.Printf("%T,%T\n", w, f1)
}
