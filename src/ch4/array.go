package main

import "fmt"

/*
	数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。
	数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。
	默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。
	在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。
	数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。
	在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化。
	如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。
	当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致传递大的数组类型将是
低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。
	虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。
*/
func main() {
	var a [3]int // array of 3 integers
	fmt.Println(a[0]) // print the first element
	fmt.Println(a[len(a)-1]) // print the last element, a[2]
	// Print the indices and elements.
	for i, v := range a {
		fmt.Printf("%d %d\n", i, v)
	}
	// Print the elements only.
	for _, v := range a {
		fmt.Printf("%d\n", v)
	}

	//使用数组字面值语法用一组值来初始化数组
	var r [3]int = [3]int{1, 2}
	fmt.Println(r[2]) // "0"

	//数组的长度是根据初始化值的个数来计算
	q := [...]int{1, 2, 3}
	fmt.Printf("%T\n", q) // "[3]int"

	//也可以指定一个索引和对应值列表的方式初始化
	arr := [...]int{99: -1}
	fmt.Printf("%T", arr)
	//数组比较
	aa := [2]int{1, 2}
	b := [...]int{1, 2}
	c := [2]int{1, 3}
	fmt.Println(aa == b, aa == c, b == c) // "true false false"
	d := [3]int{1, 2}
	fmt.Println(aa == d) // compile error: cannot compare [2]int == [3]int

	//数组字面值[32]byte{}就可以生成一个32字节的数组
}
