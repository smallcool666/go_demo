package main

import "fmt"

/*
	使用赋值语句可以更新一个变量的值
	数值变量也可以支持++递增和--递减语句（译注：自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的）

	元组赋值
		元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。
		元组赋值也可以使一系列琐碎赋值更加紧凑
		有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致

	可赋值性
		赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句将隐式地将返回操作的值赋值给结果变量等。
		不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。
		类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量（除了常量，常量赋值更灵活）。
		对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之依然。
*/

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}
func fib(n int) int {x, y := 0, 1
	for i := 0; i < n; i++ {
		x, y = y, x+y
	}
	return x
}
func main(){
	v := 1
	v++
	v--
	//v = v++ //语法错误
	fmt.Println(v)//1

	//使用元组赋值交换值
	a, b := 1, 2
	fmt.Println(a, b)//1, 2
	a, b = b, a
	fmt.Println(a, b)//2, 1

	//计算两个数的最大公约数
	c := gcd(333, 96)
	fmt.Println("最大公约数是：", c)

	//计算斐波纳契数列（Fibonacci）的第N个数
	c = fib(7)
	fmt.Println("斐波纳契数列（Fibonacci）的第7个数", c)
}