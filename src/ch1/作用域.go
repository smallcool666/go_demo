package main

import "fmt"

/*
	不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区
域内它可以被程序的其他部分引用；是一个运行时的概念。
	语法块内部声明的名字是无法被外部语法块访问的。语法决定了内部声明的名字的作用域范围。
	声明语句对应的词法域决定了作用域范围的大小。
		对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在在函数外部（也就是包级语法域）声明的名字可以在同一个包的任
	何源文件中访问的。
		对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。
		还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。
		控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。
	当编译器遇到一个名字引用时，如果它看起来像一个声明，它首先从最内层的词法域向全局的作用域查找。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部
的块分别声明过，则内部块的声明首先被找到。
	并不是所有的词法域都显式地对应到由花括弧包含的语句；还有一些隐含的规则。for循环，if和switch语句都会在条件部分创建隐式词法域，还有它们对应的执行体词法域。
	在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或
常量递归引用了自身，则会产生编译错误。
*/

func f() {}
var g = "g"
func main() {
	f := "f"
	fmt.Println(f) // "f"; local var f shadows package-level func f
	fmt.Println(g) // "g"; package-level var
	//fmt.Println(h) // compile error: undefined: h
}
