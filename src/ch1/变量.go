package main

import (
	"fmt"
	"os"
)
/*
	变量声明的一般语法如下：
			var 变量名字 类型 = 表达式
		其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。
			数值类型变量对应的零值是0；
			布尔类型变量对应的零值是false；
			字符串类型对应的零值是空字符串；
			接口或引用类型（包括slice、map、chan和函数）变量对应的零值是nil；
			数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
	零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。

	变量声明方式
	1.一般语法声明，如：var s string
	2.在一个声明语句中同时声明一组变量，如：var i, j, k int
	3.用一组初始化表达式声明并初始化一组变量（省略变量类型，可以声明多个类型不同的变量，由初始化表达式推导），
		如：var b, f, s = true, 2.3, "four" // bool, float64, string
	4.一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化，如：var f, err = os.Open(name)
	5.简短变量声明
		语法格式为：名字 := 表达式
		简短变量声明注意点：
			“:=”是一个变量声明语句，而“=”是一个变量赋值操作
			简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了
			***简短变量声明语句中必须至少要声明一个新的变量
			简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量
	6.使用内建的new函数创建变量
		表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。
		每次调用new函数都是返回一个新的变量的地址
		如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和 [0]int,有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为0的类型，因为如果类型的大小位0好话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档）
		new函数使用常见相对比较少，因为对应结构体来说，可以直接用字面量语法创建新变量的方法会更灵活
		由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。

	指针
	一个变量对应一个保存了变量对应类型值的内存空间。
	一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。
	用“var x int”声明语句声明一个x变量，那么&x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是*int，指针被称之为“指向int类型的指针”。
	如果指针名字为p，*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值；同时*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。
	对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。
	任何类型的指针的零值都是nil。如果p != nil测试为真，那么p是指向某个有效变量。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。
	***指针特别有价值的地方在于我们可以不用名字而访问一个变量,因为有许多操作都会为变量创建别名，比如指针，slice，map，chan，结构体等

	变量的声明周期
	变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。
	对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。
	而相比之下，局部变量的声明周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。
	函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

	Go语言的自动圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们避开完整的技术细节，基本的实现思路是：从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
	***因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
*/

var global *int

func test() {
	//函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它 是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。
	var x int
	x = 1
	global = &x
}
func main() {
	//一般语法声明变量
	var str string
	fmt.Println(str) //""
	//在一个声明语句中同时声明一组变量
	var i, j, k int
	fmt.Println(i, j, k)//0 0 0
	//用一组初始化表达式声明并初始化一组变量
	var a, b, c = true, 2.3, "four"
	fmt.Printf("%T, %T, %T", a, b, c)// bool, float64, string
	//通过调用一个函数，由函数返回的多个返回值初始化一组变量
	var f, err = os.Open("")
	fmt.Println(f, err)

	//简短变量声明
	t := 0.0
	//简短变量声明语句也可以用来声明和初始化一组变量
	d, e := 0, 1
	//简短变量声明语句也可以用函数的返回值来声明和初始化变量
	file, error := os.Open("")
	//简短变量声明语句中必须至少要声明一个新的变量
	//file, error := os.Open("") // compile error: no new variables
	fmt.Println(t, d, e, file, error)

	//定义指针变量
	g := 1
	p := &g // p, of type *int, points to x
	fmt.Println(*p) // "1"
	//指针表达式重新赋值
	*p = 2 // equivalent to x = 2
	fmt.Println(g) // "2"

	//指针的比较
	var  x, y int
	fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"

	*p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！

	//使用内建的new函数创建变量
	por := new(int) // p, *int 类型, 指向匿名的 int 变量
	fmt.Println(*por) // "0"
	*p = 2 // 设置 int 匿名变量的值为 2
	fmt.Println(*por) // "2"

	//局部变量的生命周期超出其局部作用于（局部变量从函数中逃逸）
	test()
}

